/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example

import app.cash.sqldelight.driver.jdbc.asJdbcDriver
import com.zaxxer.hikari.HikariConfig
import com.zaxxer.hikari.HikariDataSource
import org.example.api.api
import org.example.repository.CatsRepository
import org.example.service.CatService
import org.http4k.config.Environment
import org.http4k.config.EnvironmentKey
import org.http4k.lens.secret
import org.http4k.lens.string
import org.http4k.server.Jetty
import org.http4k.server.asServer
import java.time.Clock

val dbUrl = EnvironmentKey.string().required("JDBC_DATABASE_URL")
val dbUser = EnvironmentKey.string().optional("JDBC_DATABASE_USERNAME")
val dbPassword = EnvironmentKey.secret().required("JDBC_DATABASE_PASSWORD")

fun createApp(
    env: Environment,
    clock: Clock
): CatService {

    val dbConfig = HikariConfig().apply {
        jdbcUrl = env[dbUrl]
        username = env[dbUser]
        password = env[dbPassword]?.use { it }
    }

    val datasource = HikariDataSource(dbConfig)
        .asJdbcDriver()
        .also { Database.Schema.create(it) }
        .let { Database(it) }

    // you can use Jetty or JettyLoom which uses virtual threads
    // .asServer(SunHttp(0)) - by default http4k comes with SunHttpServer, which should not be used in production
    // if you want to use a different server, use one from this list: https://www.http4k.org/ecosystem/http4k/reference/servers/
    return CatService(
        CatsRepository(datasource.catsQueries),
        clock
    )

}
fun main() {
    createApp(Environment.ENV, Clock.systemUTC())
        .api()
        .asServer(Jetty(8080))
        .start()
}
